from __future__ import annotations

from collections.abc import Mapping
from typing import (
    Any,
    TypeVar,
)

from attrs import define as _attrs_define
from attrs import field as _attrs_field

from ..types import (
    UNSET,
    Unset,
)

T = TypeVar("T", bound="AnalysisJobContig")


@_attrs_define
class AnalysisJobContig:
    """Serializer for Documents.

    Recognized primitve fields:

        * ``StringField``
        * ``URLField``
        * ``EmailField``
        * ``IntField``
        * ``LongField``
        * ``FloatField``
        * ``DecimalField``
        * ``BooleanField``
        * ``DateTimeField``
        * ``ComplexDateTimeField``
        * ``ObjectIdField``
        * ``SequenceField`` (assumes it has integer counter)
        * ``UUIDField``
        * ``GeoPointField``
        * ``GeoJsonBaseField`` (all those fields)
        * ``DateField``

    Compound fields: ``ListField`` and ``DictField`` are mapped to corresponding DRF fields, with respect to nested
    field specification.

    The ``ReferenceField`` is handled like ``ForeignKey`` in DRF: there nested serializer autogenerated if serializer
    depth greater then 0, otherwise it's handled by it's own (results as ``str(id)``).

    For ``EmbeddedDocumentField`` also nested serializer autogenerated for non-zero depth, otherwise it is skipped.
    TODO: THIS IS PROBABLY WRONG AND SHOULD BE FIXED.

    Generic fields ``GenericReferenceField`` and ``GenericEmbeddedDocumentField`` are handled by their own with
    corresponding serializer fields.

    Not well supported or untested:

        ``FileField``
        ``ImageField``
        ``BinaryField``

    All other fields are mapped to ``DocumentField`` and probably will work wrong.

        Attributes:
            id (str):
            contig_id (str):
            analysis_id (str):
            accession (str):
            pipeline_version (str):
            job_id (int):
            length (int | Unset):
            coverage (float | Unset):
            has_cog (bool | Unset):
            has_kegg (bool | Unset):
            has_go (bool | Unset):
            has_pfam (bool | Unset):
            has_interpro (bool | Unset):
            has_antismash (bool | Unset):
            has_kegg_module (bool | Unset):
    """

    id: str
    contig_id: str
    analysis_id: str
    accession: str
    pipeline_version: str
    job_id: int
    length: int | Unset = UNSET
    coverage: float | Unset = UNSET
    has_cog: bool | Unset = UNSET
    has_kegg: bool | Unset = UNSET
    has_go: bool | Unset = UNSET
    has_pfam: bool | Unset = UNSET
    has_interpro: bool | Unset = UNSET
    has_antismash: bool | Unset = UNSET
    has_kegg_module: bool | Unset = UNSET
    additional_properties: dict[str, Any] = _attrs_field(init=False, factory=dict)

    def to_dict(self) -> dict[str, Any]:
        id = self.id

        contig_id = self.contig_id

        analysis_id = self.analysis_id

        accession = self.accession

        pipeline_version = self.pipeline_version

        job_id = self.job_id

        length = self.length

        coverage = self.coverage

        has_cog = self.has_cog

        has_kegg = self.has_kegg

        has_go = self.has_go

        has_pfam = self.has_pfam

        has_interpro = self.has_interpro

        has_antismash = self.has_antismash

        has_kegg_module = self.has_kegg_module

        field_dict: dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update(
            {
                "id": id,
                "contig_id": contig_id,
                "analysis_id": analysis_id,
                "accession": accession,
                "pipeline_version": pipeline_version,
                "job_id": job_id,
            }
        )
        if length is not UNSET:
            field_dict["length"] = length
        if coverage is not UNSET:
            field_dict["coverage"] = coverage
        if has_cog is not UNSET:
            field_dict["has_cog"] = has_cog
        if has_kegg is not UNSET:
            field_dict["has_kegg"] = has_kegg
        if has_go is not UNSET:
            field_dict["has_go"] = has_go
        if has_pfam is not UNSET:
            field_dict["has_pfam"] = has_pfam
        if has_interpro is not UNSET:
            field_dict["has_interpro"] = has_interpro
        if has_antismash is not UNSET:
            field_dict["has_antismash"] = has_antismash
        if has_kegg_module is not UNSET:
            field_dict["has_kegg_module"] = has_kegg_module

        return field_dict

    @classmethod
    def from_dict(cls: type[T], src_dict: Mapping[str, Any]) -> T:
        d = dict(src_dict)
        id = d.pop("id")

        contig_id = d.pop("contig_id")

        analysis_id = d.pop("analysis_id")

        accession = d.pop("accession")

        pipeline_version = d.pop("pipeline_version")

        job_id = d.pop("job_id")

        length = d.pop("length", UNSET)

        coverage = d.pop("coverage", UNSET)

        has_cog = d.pop("has_cog", UNSET)

        has_kegg = d.pop("has_kegg", UNSET)

        has_go = d.pop("has_go", UNSET)

        has_pfam = d.pop("has_pfam", UNSET)

        has_interpro = d.pop("has_interpro", UNSET)

        has_antismash = d.pop("has_antismash", UNSET)

        has_kegg_module = d.pop("has_kegg_module", UNSET)

        analysis_job_contig = cls(
            id=id,
            contig_id=contig_id,
            analysis_id=analysis_id,
            accession=accession,
            pipeline_version=pipeline_version,
            job_id=job_id,
            length=length,
            coverage=coverage,
            has_cog=has_cog,
            has_kegg=has_kegg,
            has_go=has_go,
            has_pfam=has_pfam,
            has_interpro=has_interpro,
            has_antismash=has_antismash,
            has_kegg_module=has_kegg_module,
        )

        analysis_job_contig.additional_properties = d
        return analysis_job_contig

    @property
    def additional_keys(self) -> list[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties
